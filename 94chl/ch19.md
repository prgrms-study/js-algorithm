# 동적 프로그래밍

문제를 작은 부분으로 쪼개서 해결해나가는 과정

## 동적 프로그래밍의 규칙

1. 중복 부분 문제  
   부분 문제들의 해결책을 결합  
   → 동일한 부분 문제에 대한 해결책이 여러번 사용되는 경우

메모이제이션(memoization)  
→ 해시테이블, 배열, 행렬에 저장

∴ 시간 복잡도 : O(2^n) → O(n)

2. 최적 부분 구조  
   부분 문제들의 최적 해결책들을 사용해 최적 해결책을 찾는 방법  
   ex. 걸음 수 채우는 방법  
   → 시간 복잡도 : O(3^n) → O(n)

## 동적 프로그래밍 예시

### 배낭 문제 알고리즘

무게와 가치를 지니는 `n`개의 항목을 최대 `w`의 무게를 담을 수 있는 배낭에 집어넣어서,  
배낭에 담긴 항목들의 가치의 합이 최대 가치를 가지도록 하는 방법  
→ 시간 복잡도 : O(n*w)  
→ 공간 복잡도 : O(n*w)

### 최장 공통 부분 수열 알고리즘

길이가 각각 `m`, `n`인 2개의 수열의 가장 긴 공통 부분 수열의 길이를 찾기  
→ 시간 복잡도 : O(m*n)  
→ 공간 복잡도 : O(m*n)

### 동전 교환 알고리즘

동전의 금액 종류 : `S = { S1, S2, ... Sm }`  
→ 금액 `n`을 동전으로 교환하기 위한 조합 수

### 편집 거리 알고리즘(레벤슈타인 거리 알고리즘)

길이 m인 문자열 str1  
길이 n인 문자열 str2  
→ str1을 str2로 변환하기 위한 최소 편집 횟수  
→ 삽입, 제거, 교환
